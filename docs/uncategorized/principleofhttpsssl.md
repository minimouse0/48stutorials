# 一文看懂HTTPS协议/SSL证书所有主流方案，为自己定制升级HTTPS最佳解决方案！

很多人都希望能为自己的网站或API升级到HTTPS，确保数据传输的安全和隐私。然而，网上现有的教程往往分为两种极端：一种是纯粹的操作指南，详细讲解每一步骤如何实现，但却缺乏原理性的解释；另一种则是深入的理论探讨，讲解HTTPS的历史、TLS的概念和加密方法，但对实际操作的指导却寥寥无几。

这种“要么实践，要么理论”的局限让许多有特殊需求的新手感到困惑和无所适从。他们花费大量时间阅读和观看这些教程，却仍然无法真正理解如何在特定情境下应用这些知识来解决实际问题。

本教程的目标是填补这一空白，通过结合理论与实践，为读者提供一个全面而实用的指南。我们将以简明易懂的方式解释HTTPS和SSL证书的工作原理，同时提供详细的操作步骤和实例，让你在了解背后原理的基础上，轻松实现网站或API的安全升级。

本教程将根据实际需求和环境，逐步引导读者理解每一个步骤的意义，从而能根据自己的具体情况定制解决方案。通过本教程，你将不仅掌握操作技能，还能理解每个步骤背后的技术原理，实现真正的知行合一。

无论你是技术小白，还是有一定经验的开发者，本教程都将帮助你快速掌握HTTPS和SSL证书的配置方法，提高网站的安全性和用户信任度。

## 让我们重温一下HTTPS的原理

HTTP协议又被称为“超文本传输协议”。它用一套固定不变的方法将文字编码成数据，然后再用一套固定不变的方法将数据解码成文字。虽然HTTP协议大大提高了互联网应用的可能性，但是由于它通过完全固定的方式编解码数据，所有人一旦截获了数据，就能够直接看到其中的内容，也因此HTTP协议是“明文传输的协议”。这样攻击者就能够随意窃听篡改数据，获取用户的密码等隐私，并且伪造数据来欺骗用户。为了保护用户隐私在，HTTPS诞生了。HTTPS加密了数据传输，保护用户数据免受窃听、篡改和中间人攻击，确保用户和服务器之间的通信安全。

具体来说，HTTPS的加密基于SSL/TLS加密层。这种加密层的核心原理是非对称加密。

传统的加密都是对称加密，例如我们两人约定一套既能够加密也能够解密的规则：A转换成Z，Z转换成T，T转换成A，不告诉其他人这套规则。然后你向我说话时，你按照这套规则推算出最终要告诉我的数据，然后告诉了我。别人虽然偷听到了，但他不知道这套加密规则，于是无法反推出我们对话的内容。然而我自己是知道加密规则的，于是我就反推出了你要对我说的话。

对称加密在二战时期很常用，军事机密都通过对称加密传输，这样他国间谍即使截获了消息也无法解读其中内容。然而这种加密需要保证加密规则不被泄露，军队中难免有泄密的粗心人，所以当时也有不少间谍成功监听到了敌国机密。

在互联网上，让客户端与服务器间采用对称加密来完全避免窃听也是完全不现实的。因为客户端需要与服务器之间规定对称加密的规则，然而这套规则如何加密？通过互联网传输的话，如果采用明文传输，那仍然会被监听到；如果采用物理方式发送（如快递），成本极高；如果采用对称式加密，那就再需要对加密规则的传输规定一套加密规则，而这套加密规则如何传输？如果还需要对称式加密，那就是传输传输传输传输传输加密规则的加密规则的加密规则的加密规则的加密规则，陷入了不可能走出的无限递归。

数学家和网络专家们协手研发了一种不需要传输所有加密规则的方式：非对称加密。通过于复杂的数学问题（如大数分解、离散对数等），可以实现加密和解密规则不相同。加密规则和解密规则虽然不同且互相之间无对应规律，但它们是成对生成的，一个公钥仅对应一个私钥。

接下来，我们将用客户端向网站服务器发送一条数据作为例子。在这个例子中，客户端是数据发送者，服务器是数据接收者。

于是数据接收者先将用于加密的公钥通过明文传输发送给数据发送者，然后数据发送者通过公钥加密数据，再将加密数据发送给数据接收者。随后，数据接收者用该公钥对应的私钥进行解密，就得到了数据发送者想要发送的数据。

在上面的过程中，公钥的发送采用明文传输，攻击者是可以看到公钥的具体内容的。然而他不具有私钥，而且非对称加密相比对称加密的最大优势就是其加密算法（公钥）无法用于反推解密算法（私钥），这样攻击者既不能直接获取私钥（因为数据接收者只公开了公钥而未公开私钥），又不能通过公钥反推出私钥。看起来，攻击者就没有任何办法解密数据了。

如果用锁头和钥匙来进行形象的比喻，就是数据接收者向数据发送者先发送用一把锁头让数据发送者用它锁住消息，并将它扔进茫茫的互联网世界传递给你。这把锁头比较特殊，别人即使知道了它的结构，也无法通过结构推理出它钥匙的形状，只有真正持有钥匙的人才能解开。途中虽然有人想偷看其中的数据，但是由于这把锁头十分特殊，他们无法通过锁头的结构推算出钥匙的形状。数据来到你手中时，你有一把可以解开这把特殊锁头的钥匙，于是你解开了锁头并阅读了数据。只要你的钥匙不被别人看到，别人就永远无法得知数据发送者发送的数据要如何解密，即使他们已经对锁头的结构了如指掌。

## 为什么所有人都在建议甚至强迫你升级HTTPS？

很多网站都需要用户提供他们的隐私信息。网站自己妥善存储用户隐私是一方面，确保传输过程中不被窃取也是一个重要的保护隐私的步骤。如果你的网站数据传输未经加密，即使你声称你的服务器不会被人入侵，你又如何保证你的服务器在与用户通信时数据不会被截获？如果攻击者截获了用户密码，即使你并没有主动向攻击者提供该信息，也成功地阻止了攻击者入侵你的服务器看到这些信息，但是攻击者仍然利用了明文传输的漏洞，在你已经给服务器本身做好绝对的安全措施的情况下窃取了用户数据，实现了盗号。这样没有加密的网站，用户凭什么输入自己的密码，这不是早晚要被盗号吗？为了让用户们上网冲浪更安全，整个互联网都在尽全力推进这种非对称加密算法，让用户无论何时都能安心地向网站方面提供数据，而无需担心被第三者窃取。

作为技术小白，有时你升级HTTPS的决定实属无奈之举。因为几乎所有的主流软件都在提醒用户不要再信任没有升级HTTPS的网站：主流浏览器如谷歌浏览器、微软edge和火狐浏览器都会为无HTTPS的网站打上醒目的不安全标识；谷歌必应等主流搜索引擎会刻意地避免收录无HTTPS的网站；主流的浏览器几乎全部默认禁止用户使用HTTPS网站访问非HTTPS的API以防止本已经妥善加密的数据因一次未加密的通信而被窃取；甚至在一些行业已经强制要求网站支持HTTPS，否则相应的网站会受到处罚甚至被行业拒之门外。

## 为什么HTTPS加密时需要SSL证书？

虽然攻击者不可以通过公钥直接解密数据，但是攻击者可以拦截公钥的发送，公钥就只发送给了攻击者，但没有被发送给真正需要接收它的数据发送者。这样，攻击者自己假装是服务器，自己生成一对密钥，然后向数据发送者发送自己的公钥。数据发送者收到了攻击者的公钥，但是攻击者将其伪造成了是原本的数据接收者提供的公钥，于是数据发送者用攻击者的公钥加密数据，然后发送给攻击者。攻击者由于持有该伪造的密钥对中的私钥，他便可以解密数据，数据发送者发送的数据便泄漏了。接下来还需要应对数据接收者那边，让他接收到正常的信息，防止攻击被他知道。于是攻击者自己伪装成数据发送者，用数据接收者提供的公钥加密数据发送者的数据并将其提供给数据接收者。这样，数据接收者收到的信息就是数据发送者的数据经自己公钥加密后的版本，接收者可以正常解密，而没有证据向他表明这些数据已经泄漏。

为了证明公钥确实来自数据接收者，发送者和接收者需要约定一个第三方，由他来向发送者证明接收者的密钥的真实性。首先数据接收者把本次要使用的公钥发送给这个第三方，这个第三方通过公钥和数据接收者的身份之间的绑定关系生成了另一串数据，这个数据就是数字证书，https要求的数字证书是数字证书的一种：SSL证书。SSL证书中记录着公钥和数据接收者的对应关系。随后这个第三方将数字证书发给数据接收者，数据接收者再将证书发给数据发送者，数据发送者一看有这个第三方提供的证书证明了公钥确实来自真正的发送者，那么就可以证明这个中间没有人攻击，可以开始数据加密和传输了。如果有人用上面的方式攻击，那么公钥的提供者就会变成攻击者，数据接收者发现公钥的提供者和证书里的提供者对不上，就会停止此次操作，要求数据发送者重新提供公钥，直到攻击者不再截获公钥。这个过程中，这个第三方就是证书颁发机构（Certificate Authority，简称CA）。

然而攻击者现在仍然可以通过伪造证书来进行攻击，攻击者向数据发送者提供证明公钥和攻击者对应关系的证书，数据发送者就无法察觉这里面的异常了。为了证明证书不是伪造的，CA需要在证书上签名，也就是附上一段自己专属的额外信息，数据发送者看到来自CA的签名，就证明证书没有被篡改。这个来自CA的签名就是数字签名。然而数字签名也可能被篡改，所以，再来一次非对称加密！

为了验证数字证书的来源，此时我们需要用到非对称加密算法的另外一个用途：验证数据来源的真实性。该算法被应用于这种用途时，加密算法被用于私钥，其加密出的内容就是数据的数字签名；而解密算法则被当作公钥，用于验证数字签名是否有效。这种算法在工作时，数据提供者生成密钥对后，先用私钥对数据进行数字签名（用加密算法加密），然后将数字签名和公钥（解密方法）发给验证者，由于只有用私钥签名（加密）的数据才能通过公钥的验证（成功解密），所以而验证者通过公钥验证数字签名，就可以确定数字签名是否被修改过。在这个过程中，数据只需要传输一次，攻击者无法要求验证者返回任何信息，这样他就无法从验证者处得到任何信息。而如果攻击者篡改了证书，就导致了证书无法再通过验证者用公钥进行的验证。攻击者也无法重新用数据提供者的公钥对应的私钥重新将数据签名，因为数据提供者的私钥没有提供给任何人。用这种方式签名，数据发送者就可以验证证书没有被篡改了。

然而攻击者可以用如下方式伪造证书的可信度：先拦截CA发来的所有信息，然后自己生成密钥对，用私钥生成签名，然后再将自己生成的公钥、用自己私钥生成的签名和CA的原始数据一并发送给数据发送者，达到伪造证书的目的。那这该怎么办？那就要验证公钥的真实性，确保这个公钥是真实来自CA的。为了验证公钥的真实性，我们还需要再来一次证书：CA将自己的公钥和自己的身份的绑定关系，像生成数据接收者的公钥和其身份的绑定关系一样，再生成一个证书。随后，这个证书仍然需要发送给用户。

然而在这个过程中如何保证证书不被篡改？这时我们突然想起来，CA是一个很大的机构，他对于许多软件开发者都有话语权，诶，那我们不妨将证书直接用物理方式交给软件开发者，让他们直接将CA自己的证书集成到自己的软件里，这样就不会遇到网络传输时数据被篡改的问题了，因为软件是可以不用网络传输的嘛。比如以前的软盘或光盘安装软件，就是通过物理方式传输的。假设软件通过光盘安装，只要用户在可信的电脑城店铺中购买正版光碟，就可以避免光盘中的CA证书被篡改。

这时你就要问了，现在都互联网时代了，谁还用光盘装软件啊，我电脑上都找不到光驱了。诶，这也是有办法的，有一种算法叫哈希，它可以将一组庞大的数据生成一小段数据：哈希值，一旦原数据发生细微的变化，生成的哈希值就会发生改变，这可以被用来快速地验证数据是否被篡改。虽然哈希值的数据量小，与原数据相比，仍然有多种原数据能够生成同一种哈希值，这被称为哈希碰撞，但是利用这种特性进行数据篡改的可能性太小了，尤其是现在哈希算法已经经过了多轮升级，一是原数据的量本来就大，光是反推出所有可能的原数据就需要花费巨量的计算资源和时间，二是即使最终找到了能够生成同样哈希值的数据，对应的软件也可能因为机器指令或源代码不符合语法规则而无法运行，就算最极端的情况软件竟然能运行，其行为也会与原软件大径相庭，用户一眼就能看出不对劲。因此用户只需要验证下载文件的哈希值就可以得知软件安装包是否被篡改，只要安装包不被篡改，内含的CA证书就不会被篡改。

那你又要问了，万一网站上显示的哈希值被篡改了呢？这也不用担心，因为网站本身采用了https协议，其中显示的哈希值在https的保护下不会被篡改。那这个https协议又是处于哪次获得未经篡改的CA证书的前提下的呢？当然是用于获取这个哈希值的软件中存储的CA证书了。这个CA证书又是在经过了上面的一系列操作才确认的未经篡改。那么鸡生蛋，蛋生鸡，是先有的https协议还是先有的未经篡改的CA证书？当然是未经篡改的CA证书。最开始的时候，有人通过正版光盘获取到了未经篡改的证书，随后用他的电脑下载好未经篡改的软件，再将软件通过https协议或物理手段传播出去，别人在电脑上装好软件后，再经过https协议再传播，这样，互联网上就形成了一个持续多年的可信的循环，所有人使用的https协议都源自那人购买的正版光盘。

但是就算是这种情况，也无法保证所有人都通过https协议传输了数据，那么软件在中间就有可能经过篡改。既然软件有可能被篡改，那么有没有更硬核的办法防止CA证书在传输过程中被篡改？CA于是动用自己的话语权说服了硬件制造商，让他们在自己的硬件里集成了CA证书。这样的CA证书位于诸如硬件安全模块（HSM）或可信平台模块（TPM）中。硬件是没法通过网络传输的，而且硬件在运输过程中受到真人的看管和现实中法律的保护，也就没有黑客在硬件的运输过程中篡改了。

然而，上面这些情况都是在基于CA有很大话语权的前提之下，现实中，如果CA有这么大的话语权，那么它就会非常大，非常权威，非常难以管理。现实中有些CA规模很小，他们无法说服开发者和硬件厂商为其集成证书。难道这些CA就没法干下去了吗？没关系，这些小CA的证书可以用其他大CA的证书来证明安全性，而大大小小CA的证书最终都要由几个十分有话语权的CA来证明真实性。这些十分有话语权的CA可以将他们的证书集成到软件或硬件中，而他们需要用自己的证书验证其他CA的证书，这样的CA就叫根CA。而根CA要验证大CA的证书，大CA又要验证小CA的证书，这样一整个验证的链条就叫证书链。证书链实现了小CA即使无法直接将证书集成到软硬件中，也可以通过委托根CA利用其权威证书来验证这个小CA的证书的真实性。有了证书链和上面的一整套加密流程，还有根CA的证书交至用户手中的这一通过其他方式确保根CA证书不被篡改的过程，我们的数据终于是可以完全保密地从数据发送者发送给数据接收者了。

然而，上面这些都是在根CA自己的私钥不被泄漏的前提下进行的。前面我们提到，为了确保大大小小CA的证书的真实性，根CA需要自己生成密钥对，然后将其证书通过物理方式基于https传输给用户。在这个过程中，攻击者由于无法伪造根CA的证书，就无法篡改被根CA证书证明的普通CA的证书。可是一旦根CA的私钥泄露，攻击者就可以通过根CA的私钥为自己伪造的普通CA的证书签名，并且数据接收者即使拥有未经篡改的根CA证书，也会将被篡改的普通证书验证为未篡改，因为被篡改的普通证书也是被根CA的私钥加密的，导致了它可以被用户手中的根CA证书证明为未加密。为了及时遏制根CA私钥泄露的安全隐患，根CA一旦发现私钥泄露，他会立即吊销对应的证书，并在整个网络上发布证书被吊销的公告。各种软件和网站程序都会高度关注这种公告，并且避免采用已经被吊销的证书来验证。

还记得我们刚才提到，数据接收者需要提供自己的身份和公钥给CA，才能证明自己和公钥的对应关系吗？你应该已经知道，在网络上，电脑拥有自己的地址，这个地址就是IP地址。这个IP地址将被作为电脑的身份发送给CA，用于和公钥形成绑定。然而，如果电脑的IP地址变了，证书就要重新申请，而我们还有一种技术用于让用户在电脑IP地址发生变化的情况下仍然能访问指定电脑：域名。这样，只要用域名去证明自己的身份，即使数据发送者的IP地址会变化，数据发送者也不需要重新申请证书。这也是SSL证书需要绑定到域名上的原因。但是电脑中了DNS污染的话，攻击者仍然是可以进行攻击的，而且这就超出HTTPS本身的能力范围了。为了防范DNS污染，可以采用配置DOH等手段，但是这已经超出了本文的讨论范围，让我们回到HTTPS本身吧。

证书需要CA机构的颁发和认证，CA机构的运行是需要费用的，所以CA会对申请SSL证书收取费用。资本太坏了，催我们升级HTTPS，然后还要在必经之路SSL证书上收钱，这不就是圈我们的钱吗？社区中有人站了出来，他们之中的代表是Let's Encrypt，以他们为首的一些CA并不对SSL证书收取费用，而是通过用高级证书的利润倒贴免费证书的成本，或者让社区出力的方式来为免费SSL证书提供服务。通过向他们申请免费的SSL证书，像我们这种需求量不大的个人用户或小团队也可以为自己的网站升级HTTPS，提升他们用户的信任度和体验，为建设安全的互联网添砖加瓦。

## 防止SSL证书被滥用——DNS-01挑战和HTTP-01挑战

SSL证书确实是确保了网站通信的安全性，但是这些都是确立在网站确实为申请者所有的前提之下的。如果申请者为不属于自己的网站或域名申请了SSL证书，那么申请者白花钱申请、申请者自己的网站加密失败或CA签发无效证书造成损失都是小事，一旦错误申请了SSL证书对应网站是真实存在的，申请者就可以向CA表示网站的域名是申请者所有而不是网站所有，这样一来就乱套了，申请者就可以随便插入客户端与真正网站的连接，发起中间人攻击。

为了防止这种现象发生，申请和续期证书时，CA需要进行一次验证，确保申请者确实拥有被申请了证书的网站。这个验证一般有两种：DNS-01挑战和HTTP-01挑战。

### DNS-01挑战

1. CA的服务器会向网站服务器发起一个挑战，要求网站证明其对域名的控制权
2. 网站服务器接收到挑战后，从CA获取一个唯一的令牌
3. 网站服务器使用令牌和账户密钥生成一个特定的哈希值，并将其作为 TXT 记录的内容
4. 网站服务器需要在域名的 DNS 区域文件中创建一个 TXT 记录，并将生成的哈希值作为记录值
5. 将生成的 TXT 记录添加到域名。
6. 网站服务器通知CA服务器已经部署了 TXT 记录
7. CA服务器会查询对应的域名是否存在且内容与预期的哈希值匹配

通过操作域名的解析记录，申请者就成功地证明了他拥有对域名的所有权。

### HTTP-01挑战

1. CA的服务器向网站服务器发起一个HTTP-01挑战，并提供一个唯一的令牌
2. 网站服务器需要将一个包含令牌和账户密钥指纹的文件放置在域名的指定路径下
3. 网站服务器通知CA服务器，验证文件已经准备好。CA服务器会尝试从指定的URL访问该文件，验证文件内容是否正确。验证成功后，这些文件就可以被删除了。

## ACME协议

这是一种用于自动化管理SSL/TLS证书的协议，通过这个协议，网站服务器可以全程自动与CA服务器通信来自动化申请和续期步骤，无需用户奔走各处手动操作。目前支持ACME协议的工具有很多，其中主流的包括Certbot和acme.sh。

## acme.sh

acme.sh是一个采用了ACME协议的证书管理脚本，很多小网站都通过它申请免费的证书。它的github仓库位于：https://github.com/acmesh-official/acme.sh。

### 使用方法

ACME有一篇官方认证的中文教程，位于 https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E 。在阅读教程时，有以下几点需要注意：

1. 如果在Windows上运行它，需要另外安装可以运行shell脚本的工具，如git（git内置了一个能运行sh脚本的工具bash）。
2. acme.sh的项目托管在github，在中国大陆时常无法访问，如果要在接入中国大陆isp的电脑上运行，建议使用watt toolkit或者魔法。
3. windows安装好后，由于电脑中原生没有运行shell脚本的软件，所以acme.sh不会在windows上添加定时任务，需要自己手动配置定时任务，可以选择windows自带的任务计划程序或者自行编写脚本
4. http-01认证只适用于网站，不适用于websocket、http api等基于http协议但本质不是网站的服务。而且你需要对网站的根目录有控制权。如果你的网站服务器不是nginx或apache，选择直接签发。
5. 如果CA是let's encrypt，http-01认证要求网站80端口开放，即使开放了但不使用，也要能重定向到其他端口，80端口未开放是不行的
6. 务必按照教程修改默认CA
7. 复制证书时，你会发现acme.sh会生成.cer结尾的文件。如果网站程序要求提供.crt文件，直接修改.cer后缀名为.crt即可。如果网站程序要求提供.pem文件，需要用openssl软件进行转换。
